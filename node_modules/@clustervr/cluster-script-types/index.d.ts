// "script" file for definition of ClusterScript 

/**
 * `$`オブジェクトは、Scriptで動作する個々のアイテムを操作するハンドルのインスタンスです。
 */
declare const $: ClusterScript;

/**
 * アイテム自身を操作するハンドルです。個々のアイテムごとに存在し、`$`オブジェクトからアクセスできます。
 */
interface ClusterScript {
  /**
   * `v`の内容をtoStringしたものをログに出力します。
   * 
   * @param v
   */
  log(v: any): void;

  /**
   * アイテムの移動させたい位置を指定します。値はアイテムのあるワールド座標系で指定します。
   * 
   * アイテムには`MovableItemコンポーネント`が付いている必要があります。
   * 位置はネットワークを介して補間して同期されるため、即座に反映されない場合があることに留意してください。
   * 
   * @param v
   */
  setPosition(v: Vector3): void;

  /**
   * アイテムの現在の位置を取得します。値はアイテムのあるワールド座標系で返されます。
   * 
   * setPositionで指定された値ではなく、移動中のアイテムの位置が返されることに留意してください。
   */
  getPosition(): Vector3;

  /**
   * アイテムの回転させたい姿勢を指定します。値はアイテムのあるワールド座標系で指定します。
   * 
   * アイテムには`MovableItemコンポーネント`が付いている必要があります。
   * 姿勢はネットワークを介して補間して同期されるため、即座に反映されない場合があることに留意してください。
   * 
   * @example
   * ```ts
   * $.setRotation(new Quaternion().setFromEulerAngles(new Vector3(90, 0, 0)));
   * ```
   * 
   * @param v 
   */
  setRotation(v: Quaternion): void;

  /**
   * アイテムの現在の姿勢を取得します。値はアイテムのあるワールド座標系で返されます。
   * 
   * setRotationで指定された値ではなく、移動中のアイテムの姿勢が返されることに留意してください。
   */
  getRotation(): Quaternion;

  /**
   * アイテムの子・孫要素に含まれる、`subNodeName`に指定した名前のオブジェクトを参照するSubNodeオブジェクトを返します。
   *
   * @param subNodeName 
   */
  subNode(subNodeName: string): SubNode;

  /**
   * アイテムのItemAudioSetListに含まれる、`itemAudioSetId`に指定したidのAudioを参照するApiAudioオブジェクトを返します。
   *
   * ItemAudioSetListの詳細は[ドキュメント](https://docs.cluster.mu/creatorkit/item-components/item-audio-set-list/)を参照してください
   * 
   * @param itemAudioSetId 
   */
  audio(itemAudioSetId: string): ApiAudio;

  /**
   * アイテムのHumanoidAnimationListに含まれる、`humanoidAnimationId`に指定したidのアニメーションを参照する{@link HumanoidAnimation}オブジェクトを返します。
   *
   * HumanoidAnimationListの詳細は[ドキュメント](https://docs.cluster.mu/creatorkit/item-components/humanoid-animation-list/)を参照してください。
   *
   * @param humanoidAnimationId
   */
  humanoidAnimation(humanoidAnimationId: string): HumanoidAnimation;

  /**
   * updateループ毎に呼ばれるcallbackを登録します。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * // 10秒間隔でログを出力する。
   * $.onUpdate(deltaTime => {
   *     let t = $.state.time ?? 0;
   *     t += deltaTime;
   *     if (t > 10) {
   *         $.log("10 sec elapsed.");
   *         t -= 10;
   *     }
   *     $.state.time = t;
   * });
   * ```
   * 
   * @param callback 
   */
  onUpdate(callback: (deltaTime: number) => void): void;

  /**
   * アイテムを掴む・手放すときに呼ばれるcallbackを登録します。アイテムには`GrabbableItemコンポーネント`が付いている必要があります。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * $.onGrab((isGrab, isLeftHande) => {
   *   if (isGrab) {
   *     if (isLeftHand) {
   *       $.log("grabbed by left hand.");
   *     } else {
   *       $.log("grabbed by right hand.");
   *     }
   *   }
   * });
   * ```
   * ベータではプレイヤーのハンドルを取得できます。
   * ```ts
   * // 掴んでいる間、移動速度を上げる。
   * $.onGrab((isGrab, isLeftHande, player) => {
   *   if (isGrab) {
   *     player.setMoveSpeedRate(2);
   *   } else {
   *     player.setMoveSpeedRate(1);
   *   }
   * });
   * ```
   *
   * @param callback
   * isGrab = 掴んだときにtrue、手放したときにfalseになります。
   * 
   * isLeftHand = 左手で掴んだときや左手で手放したときにtrue、右手で掴んだときや右手で手放したときにfalseになります。
   * 
   * player = アイテムを掴んだ・手放したプレイヤーのハンドルです。この引数はベータでのみ追加されます。
   */
  onGrab(callback: (isGrab: boolean, isLeftHand: boolean, player: PlayerHandle) => void): void;

  /**
   * 掴めないアイテムに「使う」動作をした際に呼ばれるcallbackを登録します。アイテムには1つ以上の`Colliderコンポーネント`が付いている必要があります。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * $.onInteract(() => {
   *   $.log("interacted.");
   * });
   * ```
   * ベータではプレイヤーのハンドルを取得できます。
   * ```ts
   * // インタラクトしたプレイヤーをリスポーンさせる。
   * $.onInteract(player => {
   *   player.respawn();
   * });
   * ```
   * 
   * @param callback 
   * player = アイテムにインタラクトしたプレイヤーのハンドルです。この引数はベータでのみ追加されます。
   */
  onInteract(callback: (player: PlayerHandle) => void): void;

  /**
   * 掴んでいるアイテムに「使う」動作をしたときに呼ばれるcallbackを登録します。アイテムには`GrabbableItemコンポーネント`が付いている必要があります。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   *
   * @example
   * ```ts
   * $.onUse(isDown => {
   *   $.log(`isDown: ${isDown}.`);
   * });
   * ```
   * 
   * ベータではプレイヤーのハンドルを取得できます。
   * ```ts
   * // 使ったプレイヤーに上方向の速度を加える。
   * $.onUse((isDown, player) => {
   *   if (isDown) {
   *     player.addVelocity(new Vector3(0, 5, 0));
   *   }
   * });
   * ```
   * 
   * @param callback
   * isDown = 「使う」動作を開始したときにtrue、終了したときにfalseになります。
   * 
   * player = アイテムを使ったプレイヤーのハンドルです。この引数はベータでのみ追加されます。
   */
  onUse(callback: (isDown: boolean, player: PlayerHandle) => void): void;

  /**
   * 乗ることができるアイテムに乗る・降りるときに呼ばれるcallbackを登録します。アイテムには`RidableItemコンポーネント`が付いている必要があります。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * // プレイヤーが乗っている間だけ回転する。
   * $.onRide(isGetOn => {
   *   $.state.isRiding = isGetOn;
   * });
   *
   * $.onUpdate(delataTime => {
   *   if (!$.state.isRiding) return;
   *   let t = $.state.time ?? 0;
   *   t += deltaTime;
   *   $.state.time = t % 360;
   *   $.setRotation(new Quaternion().setFromEulerAngles(0, t, 0));
   * });
   * ```
   * ベータではプレイヤーのハンドルを取得できます。
   * ```ts
   * $.onRide((isGetOn, player) => {
   *   $.state.isRiding = isGetOn;
   *   $.state.player = isGetOn ? player : null;
   * });
   * ```
   * @param callback
   * isGetOn = 乗るときにtrue、降りるときにfalseになります。
   * 
   * player = アイテムに乗った・降りたプレイヤーのハンドルです。この引数はベータでのみ追加されます。
   */
  onRide(callback: (isGetOn: boolean, player: PlayerHandle) => void): void;

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // 生成・消滅系
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * @beta
   * 指定したアイテムを空間内に生成します。アイテムが実際に生成されるまでには遅延があります。
   * 
   * アイテムの生成は、負荷や権限など様々な理由で失敗する可能性があります。
   * 
   * 生成されるアイテムのテンプレートは以下のいずれかを満たす必要があります。
   * - このスクリプトを実行しているアイテムがクラフトアイテムであった場合、そのアイテムのテンプレートと作者が同じ
   * - このスクリプトを実行しているアイテムがワールドアイテムであった場合、現在の会場と作者が同じ
   * - ベータアイテムである
   * 
   * クラフト容量が500%を超えるような生成は失敗します。
   * 
   * アイテムの生成に失敗した場合、返り値のItemHandleは指している先が存在しない状態になり、 {@link ItemHandle.exists | ItemHandle.exists} がfalseを返すようになります
   * 
   * アイテムが生成された時、この関数を呼び出した時点でのこのアイテムのオーナーが入室中であった場合、そのプレイヤーが生成されたアイテムのオーナーになります。
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内に対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生しcreateItemは失敗します。
   * 
   * ひとつのアイテムは、最大で10回/秒までcreateItemすることができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生しcreateItemは失敗します。
   * 
   * @param itemTemplateId 生成されるアイテムのTemplateId
   * @param position 生成位置 (グローバル座標)
   * @param rotation 生成姿勢 (グローバル座標)
   */
  createItem(itemTemplateId: ItemTemplateId, position: Vector3, rotation: Quaternion): ItemHandle;

  /**
   * @beta
   * アイテム自身を破棄します。アイテムが実際に破棄されるまでに遅延があります。
   * 
   * 現状、動的アイテムでしか動きません。
   * ワールド設置アイテムで実行した場合、{@link ClusterScriptError} (`executionNotAllowed`)が発生しdestroyは失敗します。
   */
  destroy(): void;

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // 近傍取得・衝突判定
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * @beta
   * 指定した球状の空間内に検知可能なコライダーが存在する自身を除くアイテムのハンドルの一覧を返します。
   * 検知可能なコライダーは、PhysicalShapeが付いているコライダー、OverlapSourceShapeが付いているコライダー、Shapeが付いていない物理衝突をするコライダーです。
   * 検知対象となるレイヤーはDefault, RidingItem, InteractableItem, GrabbingItemレイヤーです。
   * 
   * @param position 中心 (グローバル座標)
   * @param radius 半径
   * 
   * 検知したアイテムのハンドルの配列 (順序は未定義)
   */
  getItemsNear(position: Vector3, radius: number): ItemHandle[];

  /**
   * @beta
   * 指定した球状の空間内のコライダーが存在するプレイヤーのハンドルの一覧を返します。
   * 
   * @param position 中心 (グローバル座標)
   * @param radius 半径
   * 
   * 検知したプレイヤーのハンドルの配列 (順序は未定義)
   */
  getPlayersNear(position: Vector3, radius: number): PlayerHandle[];

  /**
   * @beta
   * レイが最初に衝突した物体を取得します。
   * 
   * @param position レイの原点 (グローバル座標)
   * @param direction レイの方向 (グローバル座標)
   * @param maxDistance 衝突判定を行う最大距離
   * 
   * @returns 衝突した物体 (衝突しなかった場合はnull)
   */
  raycast(position: Vector3, direction: Vector3, maxDistance: number): RaycastResult | null;

  /**
   * @beta
   * レイが衝突した全ての物体を取得します。
   * 
   * @param position レイの原点 (グローバル座標)
   * @param direction レイの方向 (グローバル座標)
   * @param maxDistance 衝突判定を行う最大距離
   * 
   * @returns 衝突した物体の配列 (順序は未定義)
   */
  raycastAll(position: Vector3, direction: Vector3, maxDistance: number): RaycastResult[];

  /**
   * @beta
   * このアイテムが別の物体と衝突したタイミングで呼ばれるcallbackを設定します。アイテムは物理挙動をする必要があります。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * $.onCollide(collision => {
   *   if (collision.object.playerHandle != null) {
   *     $.log("collide with a player.");
   *   }
   * });
   * ```
   */
  onCollide(callback: (collision: Collision) => void): void;

  /**
   * @beta
   * このアイテムのOverlapDetectorShapeに重なっている、検知対象となる物体を取得します。
   * 検知対象となる物体は、PhysicalShapeが付いているコライダー、OverlapSourceShapeが付いているコライダー、Shapeが付いていない物理衝突をするコライダーです。
   * このアイテム自身との重なりは含まれません。
   * 
   * このアイテムもしくは検知対象となる物体のどちらかは、MovableItemであるか、Rigidbodyが付いているか、CharacterControllerがついているか、プレイヤーであるかのいずれかを満たす必要があります。
   * このアイテムのOverlapDetectorShapeが衝突判定するレイヤーが検知対象となります。
   * アイテムの生成時点ですでに重なっていたり、重なっている状態で有効化された場合など、空間的には重なっている場合にもこの関数の返り値に含まれない場合があります。
   * @example
   * ```ts
   * // 自分と重なっているプレイヤーを数える。
   * let set = new Set();
   * let overlaps = $.getOverlaps();
   * for(let overlap of overlaps) {
   *   let player = overlap.object.playerHandle;
   *   if (player != null && !set.has(player.id)) {
   *     set.add(player.id);
   *   }
   * }
   * $.log(`player count: ${set.size}`);
   * ```
   */
  getOverlaps(): Overlap[];

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // 物理系
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * @beta
   * このアイテムの物理状態が更新されるタイミングで呼ばれるcallbackを設定します。
   * (UnityではFixedUpdateに対応します)
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * // 1秒間上昇して2秒かけて落下する。
   * // RigidbodyのMassが1であることが想定されています。
   * $.onPhysicsUpdate(deltaTime => {
   *   let t = $.state.time ?? 0;
   *   t += deltaTime;
   *   if (t < 1) {
   *     $.addForce(new Vector3(0, 12, 0));
   *   } else if (t > 3) {
   *     t = 0;
   *   }
   *   $.state.time = t;
   * });
   * ```
   */
  onPhysicsUpdate(callback: (deltaTime: number) => void): void;

  /**
   * @beta
   * このアイテムが、通常時に重力の影響を受けるかを取得・変更します。
   * Grab中などはアイテムは重力の影響を受けませんが、`useGravity`には影響がありません。
   * 
   * 物理挙動をするMovableItemでない場合、falseを返します。
   * 物理挙動をするMovableItemでない場合、変更しようとすると例外になります。
   */
  useGravity: boolean;

  /**
   * @beta
   * アイテムの速度(グローバル座標)を取得・変更します。
   * 
   * MovableItemでない場合は0ベクトルを返します。
   * 物理挙動をするMovableItemでない場合、変更しようとすると例外になります。
   * Grab中などに行われた変更は無視されます。
   */
  velocity: Vector3;

  /**
   * @beta
   * アイテムの角速度(グローバル座標)を取得・変更します。
   * 
   * MovableItemでない場合は0ベクトルを返します。
   * 物理挙動をするMovableItemでない場合、変更しようとすると例外になります。
   * Grab中などに行われた変更は無視されます。
   */
  angularVelocity: Vector3;

  /**
   * @beta
   * アイテムの重心に、現在のPhysicsUpdate中で有効な力を加えます。
   * {@link ClusterScript.onPhysicsUpdate}のコールバック内部でのみ使用可能で、それ以外の箇所で呼び出すと例外になります。
   * 
   * @param force 力 (グローバル座標)
   */
  addForce(force: Vector3): void;

  /**
   * @beta
   * アイテムの重心に、現在のPhysicsUpdate中で有効なトルクを加えます。
   * {@link ClusterScript.onPhysicsUpdate}のコールバック内部でのみ使用可能で、それ以外の箇所で呼び出すと例外になります。
   * 
   * @param torque トルク (グローバル座標)
   */
  addTorque(torque: Vector3): void;

  /**
   * @beta
   * アイテムの指定位置に、現在のPhysicsUpdate中で有効な力(グローバル座標)を加えます。
   * {@link ClusterScript.onPhysicsUpdate}のコールバック内部でのみ使用可能で、それ以外の箇所で呼び出すと例外になります。
   * 
   * @param force 力 (グローバル座標)
   * @param position 力点 (グローバル座標)
   */
  addForceAt(force: Vector3, position: Vector3): void;

  /**
   * @beta
   * アイテムの重心に撃力を加えます。
   * 
   * @param impulsiveForce 撃力 (グローバル座標)
   */
  addImpulsiveForce(impulsiveForce: Vector3): void;

  /**
   * @beta
   * アイテムの重心に角力積を加えます。
   * 
   * @param impulsiveTorque 角力積 (グローバル座標)
   */
  addImpulsiveTorque(impulsiveTorque: Vector3): void;

  /**
   * @beta
   * アイテムの指定位置に撃力を加えます。
   * 
   * @param impulsiveForce 撃力 (グローバル座標)
   * @param position 力点 (グローバル座標)
   */
  addImpulsiveForce(impulsiveForce: Vector3, position: Vector3): void;


  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // state系
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * @beta
   * {@link ItemHandle.send | ItemHandle.send}で送られたメッセージを受け取ったときに呼ばれるcallbackを登録します。
   * 
   * スクリプトのトップレベルでの呼び出しのみサポートされます。
   * トップレベルで複数回呼ばれた場合、最後の登録のみが有効です。
   * @example
   * ```ts
   * // 送られたメッセージがdamageかhealのときに、ログを出力する。
   * $.onReceive((messageType, arg, sender) => {
   *   switch (messageType) {
   *     case "damage":
   *       $.log(`damage: ${arg}`);
   *       break;
   *     case "heal":
   *       $.log(`heal: ${arg}`);
   *       break;
   *   }
   * });
   * ```
   * @param callback senderは送信元のアイテムを表します。
   */
  onReceive(callback: (messageType: string, arg: Sendable, sender: ItemHandle) => void): void;

  /**
   * アイテムごとのstateへのアクセスを提供します。
   * read/writeアクセスが可能です。stateのプロパティへのアクセスにより、そのプロパティ名をkeyとしてstateへアクセスすることができます。
   * 
   * @example
   * 未定義のプロパティをreadしたときは`undefined`が初期値になります。
   * ```ts
   * let v = $.state.testKey; // "testKey"というkeyの値を読み込む。1度も書き込んでいないとき、値はundefined
   * if (v == null) { v = 0.0; }
   * $.state.testKey = v + 1;
   * ```
   * 
   * ## ベータの機能
   * ベータにおいては{@link Sendable} 型の値をstateに書き込み保存することができます。
   * 
   * 具体的には、数値、文字列、boolean、{@link Vector2}、{@link Vector3}、{@link Quaternion}、{@link PlayerHandle}、{@link ItemHandle}、そしてそれらの配列と文字列をキーとしたobjectが利用可能です。
   * 
   * @example
   * ```ts
   * $.state.testKey1 = 1; // numberを書き込む
   * $.state.testKey2 = "hello"; // stringを書き込む
   * $.state.testKey3 = true; // booleanを書き込む
   * $.state.testKey4 = { foo: "bar" }; // objectを書き込む
   * $.state.testKey5 = [1, 2, 3]; // arrayを書き込む
   * $.state.testKey5 = { // 複雑なオブジェクトを書き込む
   *   array: [1, 2, 3],
   *   object: { foo: "bar" },
   * };
   * ```
   * 
   * @example
   * 配列やオブジェクトなどをstateに反映させるためには再代入が必要です。
   * ```ts
   * $.state.testKey = [1, 2, 3];
   * // $.state.testKey.push(4); // このように書いてもstateに反映されない
   * 
   * // このように書くとstateに反映される
   * const v = $.state.testKey;
   * v.push(4);
   * $.state.testKey = v;
   * ```
   */
  state: StateProxy;

  /**
   * creator kit 製ワールドで対象のメッセージを取得します。creator kit 製ワールドのアイテム以外では実行時エラーになります。
   * 
   * @example
   * ```ts
   * // 自身のアイテムを対象に foo という識別子の boolean型のメッセージを取得する。
   * $.getStateCompat("this", "foo", "boolean");
   * ```
   * 
   * @param target メッセージを取得する対象
   *
   * "this": このアイテムへのメッセージを取得します。
   *
   * "owner": このアイテムのオーナーへのメッセージを取得します。
   *
   * "global": Globalへのメッセージを取得します。
   *
   * @param key メッセージの識別子
   * @param parameterType メッセージの型
   *
   * "signal", "boolean", "float", "double", "integer", "vector2", "vector3" が利用できます。
   */
  getStateCompat(target: CompatGimmickTarget, key: string, parameterType: CompatParamType): CompatSendable | undefined;

  /**
   * creator kit 製ワールドで対象にメッセージを通知します。creator kit 製ワールドのアイテム以外では実行時エラーになります。
   * 
   * @example
   * ```ts
   * // 自身のアイテムを対象に foo という識別子で boolean型のメッセージを通知する。
   * $.setStateCompat("this", "foo", true);
   * ```
   * 
   * @param target メッセージを通知する対象
   *
   * "this": このアイテムへメッセージを通知します。
   *
   * "owner": このアイテムのオーナーへメッセージを通知します。
   *
   * @param key メッセージの識別子
   * @param value メッセージの値
   */
  setStateCompat(target: CompatStateTarget, key: string, value: CompatSendable): void;

  /**
   * creator kit 製ワールドで対象にシグナルを通知します。
   * 
   * @param target メッセージを通知する対象
   *
   * "this": このアイテムへメッセージを通知します。
   *
   * "owner": このアイテムのオーナーへメッセージを通知します。
   *
   * @param key メッセージの識別子
   */
  sendSignalCompat(target: CompatStateTarget, key: string): void;
}

/** @internal */
type StateProxy = {
  [propName: string]: Sendable;
};

/** @internal */
type CompatGimmickTarget = "this" | "owner" | "global";

/** @internal */
type CompatStateTarget = "this" | "owner";

/** @internal */
type CompatParamType = "signal" | "boolean" | "float" | "double" | "integer" | "vector2" | "vector3";

/** @internal */
type CompatSendable = boolean | number | Vector2 | Vector3;

/**
 * {@link ClusterScript.state | ClusterScript.state}に保存・{@link ItemHandle.send | ItemHandle.send}で送信可能な型です。
 * 
 * 具体的には、数値、文字列、boolean、{@link Vector2}、{@link Vector3}、{@link Quaternion}、{@link PlayerHandle}、{@link ItemHandle}、そしてそれらの配列と文字列をキーとしたobjectが{@link Sendable}となります。
 * 
 * @example
 * ```ts
 * $.state.testKey1 = 1; // numberを書き込む
 * $.state.testKey2 = "hello"; // stringを書き込む
 * $.state.testKey3 = true; // booleanを書き込む
 * 
 * // 以下ベータでのみ利用可能
 * $.state.testKey4 = { foo: "bar" }; // objectを書き込む
 * $.state.testKey5 = [1, 2, 3]; // arrayを書き込む
 * $.state.testKey5 = { // 複雑なオブジェクトを書き込む
 *   array: [1, 2, 3],
 *   object: { foo: "bar" },
 * };
 * ```
 * 
 * @example
 * ```ts
 * itemHandle.send("test1", 10); // numberを送信する
 * itemHandle.send("test2", "hello"); // stringを送信する
 * itemHandle.send("test3", true); // booleanを送信する
 * 
 * // 以下ベータでのみ利用可能
 * itemHandle.send("test4", { foo: "bar" }); // objectを送信する
 * itemHandle.send("test5", [1, 2, 3]); // arrayを送信する
 * itemHandle.send("test5", { // 複雑なオブジェクトを送信する
 *   array: [1, 2, 3],
 *   object: { foo: "bar" },
 * });
 * ```
 */
type Sendable = ExtJSON<SendablePrims>;

/** {@link Sendable}で通常のJSONに加えて送信可能な型です。 */
type SendablePrims = Vector2 | Vector3 | Quaternion | PlayerHandle | ItemHandle;

/**
 * JSONとして表現可能なデータ構造のprimitiveにTを加えた型です。
 */
type ExtJSON<T> = { [key: string]: ExtJSON<T> } | ExtJSON<T>[] | number | string | boolean | null | T;

/**
 * 自身のアイテムの子要素のオブジェクトを操作するハンドルです。 
 */
interface SubNode {
  /**
   * SubNodeの移動させたい位置を指定します。
   * 位置はネットワークを介して補間して同期されるため、即座に反映されない場合があることに留意してください。
   * 
   * @param pos 移動先の位置 (アイテムのローカル座標)
   */
  setPosition(pos: Vector3): void;

  /**
   * SubNodeの現在の位置を取得します。
   * setPositionで指定された値ではなく、移動中のSubNodeの位置が返されることに留意してください。
   *
   * 値の取得に失敗した場合、undefinedを返します。
   *
   * @returns 現在の位置 (アイテムのローカル座標)
   */
  getPosition(): Vector3;

  /**
   * SubNodeの回転させたい姿勢を指定します。
   * 姿勢はネットワークを介して補間して同期されるため、即座に反映されない場合があることに留意してください。
   * 
   * @param rot 回転 (アイテムのローカル座標)
   */
  setRotation(rot: Quaternion): void;

  /**
   * SubNodeの現在の姿勢を取得します。
   * setRotationで指定された値ではなく、移動中のSubNodeの姿勢が返されることに留意してください。
   *
   * 値の取得に失敗した場合、undefinedを返します。
   *
   * @returns 現在の姿勢 (アイテムのローカル座標)
   */
  getRotation(): Quaternion;

  /**
   * @beta
   * 現在の位置を取得します。
   * setPositionで指定された値ではなく、移動中のSubNodeの位置が返されることに留意してください。
   *
   * 値の取得に失敗した場合、nullを返します。
   *
   * @returns 現在の位置 (グローバル座標)
   */
  getGlobalPosition(): Vector3;

  /**
   * @beta
   * 現在の姿勢を取得します。
   * setRotationで指定された値ではなく、移動中のSubNodeの姿勢が返されることに留意してください。
   *
   * 値の取得に失敗した場合、nullを返します。
   *
   * @returns 現在の姿勢 (グローバル座標)
   */
  getGlobalRotation(): Quaternion;

  /**
   * SubNodeの有効状態を変更します。
   * 有効でないSubNodeとその全ての子のSubNodeは空間上で有効でなくなり、描画されず、当たり判定が無いものとして扱われます。
   * 
   * 有効状態はネットワークを介して同期されるため、即座に反映されない場合があることに留意してください。
   * 
   * @param v 有効ならtrue
   */
  setEnabled(v: boolean): void;

  /**
   * SubNodeの現在の有効状態を取得します。
   * 
   * setEnabledで指定された値ではなく、SubNodeの現在の有効状態が返されることに留意してください。
   *
   * 値の取得に失敗した場合、undefinedを返します。
   *
   */
  getEnabled(): boolean;

  /**
   * SubNodeが空間上で有効かを取得します。
   * そのSubNodeと全ての親が有効である時にそのSubNodeは空間上で有効になります。
   * 
   * setEnabledで指定された値ではなく、SubNodeの現在の有効状態が返されることに留意してください。
   *
   * 値の取得に失敗した場合、undefinedを返します。
   *
   */
  getTotalEnabled(): boolean;
}

/**
 * @beta
 * Raycastの結果を表す、readonlyな型です。
 */
interface RaycastResult {
  /**
   * @beta
   * 当たりの情報を表します。
   */
  readonly hit: Hit;

  /**
   * @beta
   * 当たった対象を表します。
   */
  readonly object: HitObject;
}

/**
 * @beta
 * Raycastの当たった地点の情報を表す、readonlyな型です。
 */
interface Hit {
  /**
   * @beta
   * 当たった点の位置(グローバル座標)を表します。
   */
  readonly point: Vector3;

  /**
   * @beta
   * 当たった面の法線(グローバル座標)を表します。
   */
  readonly normal: Vector3;
}

/**
 * @beta
 * 衝突判定がなされた対象を表すreadonlyな型です。
 * itemHandleとplayerHandleの両方がnullの場合もあります。
 */
interface HitObject {
  /**
   * @beta
   * 衝突対象がアイテムの場合、そのハンドルです。
   * 衝突対象がアイテムでない場合、nullです。
   */
  readonly itemHandle: ItemHandle | null;

  /**
   * @beta
   * 衝突対象がプレイヤーの場合、そのハンドルです。
   * 衝突対象がプレイヤーでない場合、nullです。
   */
  readonly playerHandle: PlayerHandle | null;
}

/**
 * @beta
 * アイテムと他の物体の衝突イベントを表します。
 */
interface Collision {
  /**
   * @beta
   * 衝突先の物体を表します。
   */
  readonly object: HitObject;

  /**
   * @beta
   * 衝突点の情報を表します。
   * 物体が面や辺で接触している場合、複数の衝突点として表現されます。
   */
  readonly collidePoints: CollidePoint[];

  /**
   * @beta
   * 衝突によって発生する力積の合計値です。
   */
  readonly impulse: Vector3;

  /**
   * @beta
   * 衝突した物体のアイテムから見た相対速度です。
   */
  readonly relativeVelocity: Vector3;
}

/**
 * @beta
 * アイテムと他の物体が衝突している点の一つを表します。
 */
interface CollidePoint {
  /**
   * @beta
   * 衝突元のアイテムで、どの部分が衝突しているかを表します。
   */
  readonly selfNode: ClusterScript | SubNode;

  /**
   * @beta
   * 衝突先の物体の点を表します。
   */
  readonly hit: Hit;
}

/**
 * @beta
 * アイテムと他の物体の重なりを表します。
 */
interface Overlap {
  /**
   * @beta
   * 重なっている物体を表します。
   */
  readonly object: HitObject;
  /**
   * @beta
   * アイテムのどの部分が重なっているかを表します。
   */
  readonly selfNode: ClusterScript | SubNode;
}

/**
 * @beta
 * ヒューマノイドモデルのアニメーション情報を表します。
 * HumanoidAnimationListコンポーネントにAnimationClipを登録することで、アイテムにアニメーション情報を追加できます。
 * {@link ClusterScript.humanoidAnimation | ClusterScript.humanoidAnimation}で取得することができます。
 *
 * HumanoidAnimationListの詳細は[ドキュメント](https://docs.cluster.mu/creatorkit/item-components/humanoid-animation-list/)を参照してください。
 */
interface HumanoidAnimation {

  /**
   * @beta
   * 指定した再生位置におけるヒューマノイドモデルの姿勢情報を取得します。
   * 再生位置は、0がアニメーションの先頭、getLength()の値がアニメーションの末尾を表します。
   *
   * アニメーションが存在しない場合、空のHumanoidPoseを返します。
   * @param time アニメーションの再生位置（秒数）
   */
  getSample(time: number): HumanoidPose;

  /**
   * @beta
   * アニメーションの再生時間を秒数で返します。
   *
   * アニメーションが存在しない場合、0を返します。
   */
  getLength(): number;
}

/**
 * @beta
 * ヒューマノイドモデルの姿勢情報を表します。
 * アバターのルートとはおおまかにアバターの足元の位置を表します。
 */
declare class HumanoidPose {
  /**
   * @beta HumanoidPoseを生成します。
   */
  constructor(centerPosition: Vector3 | null, centerRotation: Quaternion | null, muscles: Muscles | null);

  /**
   * @beta
   * アバターの重心の位置をアバターのルートを原点とする正規化された相対座標で示したものです。
   * スケールがアバターの大きさによって正規化されているため、グローバル座標での位置変化を指定するためには非推奨です。
   * (代わりに、{@link PlayerHandle.setPosition | PlayerHandle.setPosition}が利用可能です)。
   */
  centerPosition: Vector3 | null;

  /**
   * @beta
   * アバターの重心の回転をアバターのルートからの相対回転で示したものです。
   */
  centerRotation: Quaternion | null;

  muscles: Muscles | null;
}

/**
 * @beta
 * ヒューマノイドモデルの姿勢情報の、"muscle"値です。
 * 各muscle値は[-1,1]に正規化された「曲げ」の量を表します。
 */
declare class Muscles {
  /**
   * @beta
   * 全ての要素がundefinedなMusclesを生成します。
   * 値がundefinedなmuscleは指定されていないと見なされます。
   */
  constructor();
  spineFrontBack: number | undefined;
  spineLeftRight: number | undefined;
  spineTwistLeftRight: number | undefined;
  chestFrontBack: number | undefined;
  chestLeftRight: number | undefined;
  chestTwistLeftRight: number | undefined;
  upperChestFrontBack: number | undefined;
  upperChestLeftRight: number | undefined;
  upperChestTwistLeftRight: number | undefined;
  neckNodDownUp: number | undefined;
  neckTiltLeftRight: number | undefined;
  neckTurnLeftRight: number | undefined;
  headNodDownUp: number | undefined;
  headTiltLeftRight: number | undefined;
  headTurnLeftRight: number | undefined;
  leftEyeDownUp: number | undefined;
  leftEyeInOut: number | undefined;
  rightEyeDownUp: number | undefined;
  rightEyeInOut: number | undefined;
  jawClose: number | undefined;
  jawLeftRight: number | undefined;
  leftUpperLegFrontBack: number | undefined;
  leftUpperLegInOut: number | undefined;
  leftUpperLegTwistInOut: number | undefined;
  leftLowerLegStretch: number | undefined;
  leftLowerLegTwistInOut: number | undefined;
  leftFootUpDown: number | undefined;
  leftFootTwistInOut: number | undefined;
  leftToesUpDown: number | undefined;
  rightUpperLegFrontBack: number | undefined;
  rightUpperLegInOut: number | undefined;
  rightUpperLegTwistInOut: number | undefined;
  rightLowerLegStretch: number | undefined;
  rightLowerLegTwistInOut: number | undefined;
  rightFootUpDown: number | undefined;
  rightFootTwistInOut: number | undefined;
  rightToesUpDown: number | undefined;
  leftShoulderDownUp: number | undefined;
  leftShoulderFrontBack: number | undefined;
  leftArmDownUp: number | undefined;
  leftArmFrontBack: number | undefined;
  leftArmTwistInOut: number | undefined;
  leftForearmStretch: number | undefined;
  leftForearmTwistInOut: number | undefined;
  leftHandDownUp: number | undefined;
  leftHandInOut: number | undefined;
  rightShoulderDownUp: number | undefined;
  rightShoulderFrontBack: number | undefined;
  rightArmDownUp: number | undefined;
  rightArmFrontBack: number | undefined;
  rightArmTwistInOut: number | undefined;
  rightForearmStretch: number | undefined;
  rightForearmTwistInOut: number | undefined;
  rightHandDownUp: number | undefined;
  rightHandInOut: number | undefined;
  leftThumb1Stretched: number | undefined;
  leftThumbSpread: number | undefined;
  leftThumb2Stretched: number | undefined;
  leftThumb3Stretched: number | undefined;
  leftIndex1Stretched: number | undefined;
  leftIndexSpread: number | undefined;
  leftIndex2Stretched: number | undefined;
  leftIndex3Stretched: number | undefined;
  leftMiddle1Stretched: number | undefined;
  leftMiddleSpread: number | undefined;
  leftMiddle2Stretched: number | undefined;
  leftMiddle3Stretched: number | undefined;
  leftRing1Stretched: number | undefined;
  leftRingSpread: number | undefined;
  leftRing2Stretched: number | undefined;
  leftRing3Stretched: number | undefined;
  leftLittle1Stretched: number | undefined;
  leftLittleSpread: number | undefined;
  leftLittle2Stretched: number | undefined;
  leftLittle3Stretched: number | undefined;
  rightThumb1Stretched: number | undefined;
  rightThumbSpread: number | undefined;
  rightThumb2Stretched: number | undefined;
  rightThumb3Stretched: number | undefined;
  rightIndex1Stretched: number | undefined;
  rightIndexSpread: number | undefined;
  rightIndex2Stretched: number | undefined;
  rightIndex3Stretched: number | undefined;
  rightMiddle1Stretched: number | undefined;
  rightMiddleSpread: number | undefined;
  rightMiddle2Stretched: number | undefined;
  rightMiddle3Stretched: number | undefined;
  rightRing1Stretched: number | undefined;
  rightRingSpread: number | undefined;
  rightRing2Stretched: number | undefined;
  rightRing3Stretched: number | undefined;
  rightLittle1Stretched: number | undefined;
  rightLittleSpread: number | undefined;
  rightLittle2Stretched: number | undefined;
  rightLittle3Stretched: number | undefined;

}

/**
 * @beta
 * アイテムの元となる、アイテムテンプレートのIDを表します。
 * {@link ClusterScript.createItem | ClusterScript.createItem}等で利用されます。
 */
declare class ItemTemplateId {
  /**
   * @beta
   * clusterにアップロードされたクラフトアイテムのテンプレートのIDを表すインスタンスを生成します。
   * 
   * クラフトアイテムのテンプレートのIDはCreator Kitの「クラフトアイテムの情報取得」機能から取得することが出来ます。
   * 「クラフトアイテムの情報取得」ウィンドウに表示される、 `ItemTemplateId =` 以降の文字列がそのアイテムのテンプレートのIDです。
   * 詳細は[ドキュメント](https://docs.cluster.mu/creatorkit/item/craft-item-upload/get-craft-item-informations/)を参照してください。
   * 
   * @example
   * ```ts
   * let itemTemplateId = new ItemTemplateId("12345678-abcd-1234-abcd-123456789abc");
   * ```
   * 
   * @param id UUID形式の文字列
   */
  constructor(id: string);
}


/**
 * @beta
 * アイテムを外部から操作するためのハンドルです。
 * ハンドルは自分自身を指していることも、それ以外を指していることも、指している先が存在しないこともあります。
 */
interface ItemHandle {

  /**
   * @beta
   * 空間内のアイテムを一意に表すIDの文字列表現です。
   * idが等しいItemHandleは同一のアイテムを指し示します。
   */
  readonly id: string;

  /**
   * @beta
   * アイテムが存在する場合、trueを返します。
   * ロード中でもtrueを返すことがあります。
   */
  exists(): boolean;

  /**
   * @beta
   * アイテムにメッセージを送ります。送られた対象は{@link ClusterScript.onReceive | ClusterScript.onReceive}に設定したコールバックを呼ぶことが期待されます。
   * メッセージのペイロード（`arg`引数）に使用できるデータについては{@link Sendable}を参照してください。
   * 
   * 削除されたアイテムに対してや、無効なitemHandleに対しては無視されます。
   * 
   * @example
   * 以下は{@link ClusterScript.onReceive | ClusterScript.onReceive}の例に対応するメッセージの例です。
   * ```ts
   * itemHandle.send("damage", 20);
   * itemHandle.send("heal", 10);
   * ```
   *
   * 以下の例では、アイテムを使用したプレイヤーのハンドルを"chase"というメッセージタイプで周囲2m以内のアイテムに対して送信します。
   * ```ts
   * $.onUse((isDown, player) => {
   *   if (!isDown) return;
   *   let items = $.getItemsNear($.getPosition(), 2);
   *   for (let item of items) {
   *     item.send("chase", player);
   *   }
   * });
   * ```
   *
   * 受け取ったメッセージをどう処理するかは、受け取る側のアイテムの{@link ClusterScript.onReceive | ClusterScript.onReceive}に記述します。
   * 以下の例では、アイテムはプレイヤーを5秒間追いかけます。
   * ```ts
   * $.onReceive((messageType, arg, sender) => {
   *   switch (messageType) {
   *     case "chase":
   *       $.state.target = arg;
   *       $.state.time = 0;
   *       break;
   *   }
   * });
   * 
   * $.onUpdate(deltaTime => {
   *   let target = $.state.target;
   *   if (!target) return;
   * 
   *   let time = $.state.time ?? 0;
   *   time += deltaTime;
   *   $.state.time = time;
   * 
   *   if (time > 5) {
   *     $.state.target = null;
   *     return;
   *   }
   * 
   *   $.setPosition($.getPosition().lerp(target.getPosition(), 0.02));
   * });
   * ```
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒までsendすることができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生しsendは失敗します。
   * 
   * #### 容量の制限:
   * 
   * `arg`のデータサイズが内部的な制限を超えている場合、{@link ClusterScriptError} (`requestSizeLimitExceeded`) が発生しsendは失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のアイテムに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生しsendは失敗します。
   * 
   * @param messageType メッセージの種別を表す短い文字列
   * @param arg メッセージのペイロード
   */
  send(messageType: string, arg: Sendable): void;

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // 力系
  ////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * @beta
   * アイテムの重心に撃力を加えます。アイテムが力の影響を受けない場合無視されます。
   * 重心以外に撃力を加えたい場合は{@link ItemHandle.addImpulsiveForceAt}を使用してください。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のアイテムに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param force 撃力 (グローバル座標)
   */
  addImpulsiveForce(force: Vector3): void;

  /**
   * @beta
   * アイテムの重心に角力積を加えます。アイテムが力の影響を受けない場合単に無視されます。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のアイテムに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param torque 角力積 (グローバル座標)
   */
  addImpulsiveTorque(torque: Vector3): void;

  /**
   * @beta
   * アイテムの指定位置に撃力を加えます。アイテムが力の影響を受けない場合単に無視されます。
   * 力を加える先にアイテムの実体 (PhysicalShapeやメッシュ等)が存在する必要はありません。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のアイテムに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param impulse 撃力 (グローバル座標)
   * @param position 位置 (グローバル座標)
   */
  addImpulsiveForceAt(impulse: Vector3, position: Vector3): void;
}

/**
 * @beta
 * プレイヤーを外部から操作するためのハンドルです。
 * プレイヤーのアバターを変更してもPlayerHandleは不変です。
 * ユーザーは入室ごとに別のプレイヤーとして取り扱われます。
 * このため、再入室したユーザーに対しては再度PlayerHandleを取得しなおす必要があります。
 * 
 */
interface PlayerHandle {
  /**
 * @beta
 * 空間内のプレイヤーを一意に表すIDの文字列表現です。
 * idが等しいPlayerHandleは同一のプレイヤーを指し示します。
 */
  readonly id: string;

  /**
   * @beta プレイヤーが入室中ならtrueを返します。
   * プレイヤーが通信の不具合などで一時的に非表示になっている場合もtrueを返します。
   *
   * プレイヤーが存在しない場合、falseを返します。
   *
   */
  exists(): boolean;

  /**
   * @beta プレイヤーの位置を変更します。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param position 足元の中心位置の移動先 (グローバル座標)
   */
  setPosition(position: Vector3): void;

  /**
   * @beta プレイヤーの向きを変更します。
   * 体の向きは鉛直のままです (カメラや首の向きはピッチの影響を受けます)
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param rotation プレイヤーの向き (グローバル座標)
   */
  setRotation(rotation: Quaternion): void;

  /**
   * @beta
   * プレイヤーのアバターモデルの姿勢を、指定したHumanoidPoseで上書きします。
   * HumanoidPoseのrootPosition, rootRotation, muscleのうち、指定されていない要素については上書きされません。
   * ポーズの上書きは、次に`setHumanoidPose`が呼び出されるまで継続します。
   * 引数にnullまたは値を持たないHumanoidPoseを渡すことで、`setHumanoidPose`によるポーズの上書きを全て解除することができます。
   * 
   * `setHumanoidPose`によるポーズの上書きは、エモートや`RidableItem`による姿勢の変更よりも優先されます。
   *
   * VRではプレイヤーが掴んでいるアイテムは指定されたポーズに追従しますが、1人称のカメラやUI操作などは影響を受けません。
   * @example
   * ```ts
   * // MyAnimationというIdのHumanoidAnimationを取得する。
   * const animation = $.humanoidAnimation("MyAnimation");
   * // ポーズを上書きする。
   * playerHandle.setHumanoidPose(animation.getSample(0));
   * // 上書きを解除する。
   * playerHandle.setHumanoidPose(null);
   * ```
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   */
  setHumanoidPose(pose: HumanoidPose): void;

  /**
   * @beta プレイヤーの位置（グローバル座標）を取得します。取得に失敗したときは`null`を返します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   */
  getPosition(): Vector3 | null;

  /**
   * @beta プレイヤーの向き（グローバル座標）を取得します。取得に失敗したときは`null`を返します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   */
  getRotation(): Quaternion | null;

  /**
   * @beta プレイヤーをリスポーンさせます。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   */
  respawn(): void;

  /**
   * @beta プレイヤーに速度を加えます。
   * プレイヤーの最終的な移動速度は、加えられた速度とプレイヤー入力の両方から決定されます。
   * プレイヤーが地面に接している間、加えられた速度は摩擦と似たような原理で減速し続けます。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   *
   * @param velocity 加えられる速度 (グローバル座標)
   */
  addVelocity(velocity: Vector3): void

  /**
   * @beta プレイヤーの移動速度の倍率を変更します。初期値は1です。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param moveSpeedRate 移動速度の倍率
   */
  setMoveSpeedRate(moveSpeedRate: number): void

  /**
   * @beta プレイヤーのジャンプ速度の倍率を変更します。初期値は1です。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param jumpSpeedRate ジャンプ速度の倍率
   */
  setJumpSpeedRate(jumpSpeedRate: number): void

  /**
   * @beta プレイヤーにかかる重力加速度（単位：m/s^2）を変更します。初期値は-9.81です。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param gravity 重力加速度
   */
  setGravity(gravity: number): void

  /**
   * @beta プレイヤーに設定された移動速度、ジャンプ速度、重力をリセットします。
   * 
   * #### 頻度の制限:
   * 
   * ひとつのアイテムは、最大で10回/秒まで他のハンドルに対して操作することができます。
   * 瞬間的にこの制限を超えることはできますが、平均回数はこの制限を下回るようにしてください。
   * 制限を超えている場合、{@link ClusterScriptError} (`rateLimitExceeded`)が発生し操作は失敗します。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   */
  resetPlayerEffects(): void

  /**
   * @beta プレイヤーのヒューマノイドボーンの位置を取得します。
   * 値はグローバル座標です。
   * アバターのロードが完了していない場合や、アバターにボーンが存在しない場合は`null`が返されます。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param bone ヒューマノイドボーン
   */
  getHumanoidBonePosition(bone: HumanoidBone): Vector3 | null

  /**
   * @beta プレイヤーのヒューマノイドボーンの回転を取得します。
   * 値はグローバル座標です。
   * アバターのロードが完了していない場合や、アバターにボーンが存在しない場合は`null`が返されます。
   * 
   * #### 距離の制限: 
   * 
   * このメソッドは、このスクリプトを実行しているアイテムから
   * 30メートル以内のプレイヤーに対してのみ実行できます。
   * 制限を超えている場合、{@link ClusterScriptError} (`distanceLimitExceeded`)が発生し操作は失敗します。
   * 
   * @param bone ヒューマノイドボーン
   */
  getHumanoidBoneRotation(bone: HumanoidBone): Quaternion | null
}

/**
 * 
 */

/**
 * 音声を操作するハンドルです。 
 */
interface ApiAudio {
  /**
   * Audioを再生します。
   * 
   * 再生中のAudioに対して実行した場合、現在の再生を停止し、再度再生します。
   */
  play(): void;

  /**
   * Audioを停止します。
   */
  stop(): void;

  /**
   * Audioの音量を表すプロパティです。
   * 
   * 初期値は1で、0以上2.5以下の値をとります。
   */
  volume: number;

  /**
   * Audioの再生位置となるSubNodeを指定します。
   * 
   * 存在しないSubNodeが指定された場合はAudioの再生位置がアイテムのルート位置になります。
   * 
   * @param v 
   */
  attach(subNode: SubNode): void;

  /**
   * Audioの再生位置をアイテムのルート位置にします。
   */
  attachToRoot(): void;
}

/**
 * クォータニオンです。
 * 
 * 値を操作するメソッドは基本的に破壊的操作であるため、影響を与えたくない場合は明示的に`clone()`を呼び出してインスタンスを複製してください。
 */
declare class Quaternion {
  readonly x: number;
  readonly y: number;
  readonly z: number;
  readonly w: number;

  constructor();
  constructor(x: number, y: number, z: number, w: number);

  /**
   * 自身の値と`v`を比較し、ほとんど等しいときに`true`を返します。
   * 
   * @param v
   */
  equals(v: Quaternion): boolean;
  /**
   * 自身の`x`, `y`, `z`, `w`成分の値を設定します。
   * 
   * @param x 
   * @param y 
   * @param z 
   * @param w 
   */
  set(x: number, y: number, z: number, w: number): this;
  /**
   * `axis`の周りを`degree`度回転する値で自身を更新します。
   * 
   * @example
   * ```ts
   * new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), 90);
   * ```
   * 
   * @param axis 
   * @param degree 
   * 
   */
  setFromAxisAngle(axis: Vector3, degree: number): this;
  /**
   * オイラー角表現での回転で自身を更新します。軸の適用順序はZXYの順となります。
   * 
   * @example
   * ```ts
   * new Quaternion().setFromEulerAngles(new Vector3(90, 0, 0));
   * ```
   * 
   * @param v 
   */
  setFromEulerAngles(v: Vector3): this;
  /**
   * オイラー角表現での回転の値を返します。
   */
  createEulerAngles(): Vector3;
  /**
   * インスタンスを複製します。
   */
  clone(): Quaternion;
  /**
   * `v`の値を自身に乗算します。
   * 
   * @param v 
   */
  multiply(v: Quaternion): this;
  /**
   * 自身の値を単位回転で更新します。これは回転のない状態を指します。
   */
  identity(): this;
  /**
   * 自身の値を反転します。
   */
  invert(): this;
  /**
   * 自身の値を正規化します。
   */
  normalize(): this;
  /**
   * 自身と`v`の回転の内積を計算します。
   * @param v 
   */
  dot(v: Quaternion): number;
  /**
   * 自身（クォータニオン）を4次元のベクトルとみたときの長さを返します。
   */
  length(): number;
  /**
   * 自身（クォータニオン）を4次元のベクトルとみたときの2乗の長さを返します。
   */
  lengthSq(): number;
  /**
   * 自身 と `v` の間を `a` で球状に補間した値を計算し、計算結果で自身の値を更新します。
   * 
   * @example
   * ```ts
   * let min = new Quaternion().identity();
   * let max = new Quaternion().setFromEulerAngles(0, 45, 0);
   * min.clone().slerp(max, 0.5);
   * ```
   * 
   * @param v 
   * @param a 補間の範囲を [0, 1] で指定します。
   */
  slerp(v: Quaternion, a: number): this;
}

/**
 * 3Dベクトルです。
 * 
 * 値を操作するメソッドは基本的に破壊的操作であるため、影響を与えたくない場合は明示的に`clone()`を呼び出してインスタンスを複製してください。
 */
declare class Vector3 {
  readonly x: number;
  readonly y: number;
  readonly z: number;

  constructor();
  constructor(x: number, y: number, z: number);

  /**
   * 自身の値と`v`を比較し、ほとんど等しいときに`true`を返します。
   * 
   * @param v
   */
  equals(v: Vector3): boolean;
  /**
   * 自身の`x`, `y`, `z`成分の値を設定します。
   * 
   * @param x 
   * @param y 
   * @param z 
   */
  set(x: number, y: number, z: number): this;
  /**
   * インスタンスを複製します。
   */
  clone(): Vector3;
  /**
   * `v`の値を自身に加算します。
   * 
   * @param v 
   */
  add(v: Vector3): this;
  /**
   * スカラー値`s`を自身の`x`, `y`, `z`成分に加算します。
   * @param s 
   */
  addScalar(s: number): this;
  /**
   * `v`の値で自身から減算します。
   * 
   * @param v 
   */
  sub(v: Vector3): this;
  /**
   * スカラー値`s`で自身の`x`, `y`, `z`成分を減算します。
   * @param s 
   */
  subScalar(s: number): this;
  /**
   * `v`の値を自身に乗算します。
   * 
   * @param v 
   */
  multiply(v: Vector3): this;
  /**
   * スカラー値`s`を自身に乗算します。
   * 
   * @param s 
   */
  multiplyScalar(s: number): this;
  /**
   * `v`の値で自身を除算します。
   * 
   * @param v 
   */
  divide(v: Vector3): this;
  /**
   * スカラー値`s`で自身を乗算します。
   * 
   * @param s 
   */
  divideScalar(s: number): this;
  /**
   * 自身の値を反転します。
   */
  negate(): this;
  /**
   * 自身の値を正規化します。
   */
  normalize(): this;
  /**
   * 自身と`v`のベクトルの内積を計算します。
   * 
   * @param v 
   */
  dot(v: Vector3): number;
  /**
   * 自身と`v`のベクトルの外積を計算し、計算結果で自身の値を更新します。
   * 
   * @param v 
   */
  cross(v: Vector3): this;
  /**
   * 自身（ベクトル）の長さを返します。
   */
  length(): number;
  /**
   * 自身（ベクトル）の2乗の長さを返します。
   */
  lengthSq(): number;
  /**
   * 自身 と `v` の間を `a` で線形に補間した値を計算し、計算結果で自身の値を更新します。
   * 
   * @param v 
   * @param a 補間の範囲を [0, 1] で指定します。
   */
  lerp(v: Vector3, a: number): this;
  /**
   * `q`の回転を自身に適用します。
   * 
   * @param q 
   */
  applyQuaternion(q: Quaternion): this
}

/**
 * 2Dベクトルです。
 * 
 * 値を操作するメソッドは基本的に破壊的操作であるため、影響を与えたくない場合は明示的に`clone()`を呼び出してインスタンスを複製してください。
 */
declare class Vector2 {
  readonly x: number;
  readonly y: number;

  constructor();
  constructor(x: number, y: number)

  /**
   * 自身の値と`v`を比較し、ほとんど等しいときに`true`を返します。
   * 
   * @param v
   */
  equals(v: Vector2): boolean;
  /**
   * 自身の`x`, `y`成分の値を設定します。
   * 
   * @param x 
   * @param y 
   */
  set(x: number, y: number): this;
  /**
   * インスタンスを複製します。
   */
  clone(): Vector2;
  /**
   * `v`の値を自身に加算します。
   * 
   * @param v 
   */
  add(v: Vector2): this;
  /**
   * スカラー値`s`を自身の`x`, `y`成分に加算します。
   * @param s 
   */
  addScalar(s: number): this;
  /**
   * `v`の値で自身から減算します。
   * 
   * @param v 
   */
  sub(v: Vector2): this;
  /**
   * スカラー値`s`で自身の`x`, `y`成分を減算します。
   * @param s 
   */
  subScalar(s: number): this;
  /**
   * `v`の値を自身に乗算します。
   * 
   * @param v 
   */
  multiply(v: Vector2): this;
  /**
   * スカラー値`s`を自身に乗算します。
   * 
   * @param s 
   */
  multiplyScalar(s: number): this;
  /**
   * `v`の値で自身を除算します。
   * 
   * @param v 
   */
  divide(v: Vector2): this;
  /**
   * スカラー値`s`で自身を乗算します。
   * 
   * @param s 
   */
  divideScalar(s: number): this;
  /**
   * 自身の値を反転します。
   */
  negate(): this;
  /**
   * 自身の値を正規化します。
   */
  normalize(): this;
  /**
   * 自身と`v`のベクトルの内積を計算します。
   * 
   * @param v 
   */
  dot(v: Vector2): number;
  /**
   * 自身と`v`のベクトルの2Dの外積の大きさを計算します。
   * 
   * @param v 
   */
  cross(v: Vector2): number;
  /**
   * 自身（ベクトル）の長さを返します。
   */
  length(): number;
  /**
   * 自身（ベクトル）の2乗の長さを返します。
   */
  lengthSq(): number;
  /**
   * 自身 と `v` の間を `a` で線形に補間した値を計算し、計算結果で自身の値を更新します。
   * 
   * @param v 
   * @param a 補間の範囲を [0, 1] で指定します。
   */
  lerp(v: Vector2, a: number): this;
}

/**
 * @beta
 * ヒューマノイドモデルのボーンです。
 */
declare enum HumanoidBone {
  Hips,
  LeftUpperLeg,
  RightUpperLeg,
  LeftLowerLeg,
  RightLowerLeg,
  LeftFoot,
  RightFoot,
  Spine,
  Chest,
  Neck,
  Head,
  LeftShoulder,
  RightShoulder,
  LeftUpperArm,
  RightUpperArm,
  LeftLowerArm,
  RightLowerArm,
  LeftHand,
  RightHand,
  LeftToes,
  RightToes,
  LeftEye,
  RightEye,
  Jaw,
  LeftThumbProximal,
  LeftThumbIntermediate,
  LeftThumbDistal,
  LeftIndexProximal,
  LeftIndexIntermediate,
  LeftIndexDistal,
  LeftMiddleProximal,
  LeftMiddleIntermediate,
  LeftMiddleDistal,
  LeftRingProximal,
  LeftRingIntermediate,
  LeftRingDistal,
  LeftLittleProximal,
  LeftLittleIntermediate,
  LeftLittleDistal,
  RightThumbProximal,
  RightThumbIntermediate,
  RightThumbDistal,
  RightIndexProximal,
  RightIndexIntermediate,
  RightIndexDistal,
  RightMiddleProximal,
  RightMiddleIntermediate,
  RightMiddleDistal,
  RightRingProximal,
  RightRingIntermediate,
  RightRingDistal,
  RightLittleProximal,
  RightLittleIntermediate,
  RightLittleDistal,
  UpperChest,
}

/**
 * @beta
 * 実行が許可されていない操作を実行したときに発生する例外です。
 * すべてのAPIはこの例外を投げる可能性があります。
 * 
 * 操作の実行が許可されるかどうかは、ベータ許可状態、距離、空間内の負荷、
 * ユーザーのステータスなど様々な要素によって動的に変化します。
 * 
 * 許可されていない操作の種類に応じてフィールドのboolean値がtrueになります。
 * 
 * 複数の許可が足りていない場合には
 * 複数のフィールドが同時にtrueになることがあります。
 */
interface ClusterScriptError extends Error {
  /**
   * 距離制限により実行が許可されていない場合、trueとなります。
   */
  distanceLimitExceeded: boolean;
  /**
   * レート制限により実行が許可されていない場合、trueとなります。
   */
  rateLimitExceeded: boolean;
  /**
   * リクエストサイズ制限により実行が許可されていない場合、trueとなります。
   */
  requestSizeLimitExceeded: boolean;
  /**
   * 実行が許可されていない場合、trueとなります。
   * 
   * betaの仕様が許可されていない環境でベータのAPIを呼び出した場合などに発生します。
   */
  executionNotAllowed: boolean;
  /**
   * エラーメッセージです。
   */
  message: string;
}
